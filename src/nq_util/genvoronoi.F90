!***********************************************************************
! This file is part of OpenMolcas.                                     *
!                                                                      *
! OpenMolcas is free software; you can redistribute it and/or modify   *
! it under the terms of the GNU Lesser General Public License, v. 2.1. *
! OpenMolcas is distributed in the hope that it will be useful, but it *
! is provided "as is" and without any express or implied warranties.   *
! For more details see the full text of the license in the file        *
! LICENSE or in <http://www.gnu.org/licenses/>.                        *
!***********************************************************************

subroutine GenVoronoi(Coor,nR_Eff,nNQ,Alpha,rm,iNQ)
!***********************************************************************
!                                                                      *
!     This version of GenVoronoi computes the radial quadrature points *
!     and computes datas useful for the angular quadrature.            *
!     The angular part is generated by Subblock.                       *
!                                                                      *
!***********************************************************************

use NQ_Structure, only: NQ_Data
use nq_Info

implicit real*8(a-h,o-z)
#include "itmax.fh"
#include "real.fh"
#include "stdalloc.fh"
real*8 Coor(3)
integer nR_Eff(nNQ)
real*8 Alpha(2), rm(2)
logical Process
dimension Dum(2,1)

!                                                                      *
!***********************************************************************
!                                                                      *
!#define _DEBUGPRINT_
#ifdef _DEBUGPRINT_
write(6,*) 'nR,L_Quad=',nR,L_Quad
#endif
if (L_Quad > lMax_NQ) then
  call WarningMessage(2,'GenVoronoi: L_Quad > lMax_NQ')
  write(6,*) 'Redimension lMax_NQ in nq_info'
  write(6,*) 'lMax_NQ=',lMax_NQ
  write(6,*) 'L_Quad=',L_Quad
  call Abend()
end if
l_Max = int(rm(1))
Radius_Max = Eval_RMax(Alpha(1),l_Max,rm(2))
#ifdef _DEBUGPRINT_
write(6,*) 'Alpha(1)=',Alpha(1)
write(6,*) 'l_max=',l_max
write(6,*) 'rm(2)=',rm(2)
write(6,*) 'Radius_Max=',Radius_Max
write(6,*)
#endif
!                                                                      *
!***********************************************************************
!                                                                      *
! Generate radial quadrature points. Observe that the integrand
! vanish at (r=0.0).

if (Quadrature == 'MHL') then

  iANr = NQ_Data(iNQ)%Atom_Nr
  RBS = Bragg_Slater(iANr)
  Alpha(1) = RBS
  mR = nR-1
  call mma_allocate(NQ_Data(iNQ)%R_Quad,2,mR,Label='R_Quad')
  NQ_Data(iNQ)%R_Quad(:,:) = Zero
  call GenRadQuad_MHL(NQ_Data(iNQ)%R_Quad,nR,nR_Eff(iNQ),Alpha(1))
  call Truncate_Grid(NQ_Data(iNQ)%R_Quad,mR,nR_Eff(iNQ),Radius_Max)
  mR = nR_Eff(iNQ)
  NQ_Data(iNQ)%R_max = NQ_Data(iNQ)%R_Quad(1,mR)

else if (Quadrature == 'LOG3') then

  rm(1) = Three
  ! alpha=5 (alpha=7 for alkali and rare earth metals)
  Alpha(1) = Five
  iANr = NQ_Data(iNQ)%Atom_Nr
  if ((iANr == 3) .or. (iANr == 4) .or. (iANr == 11) .or. (iANr == 12) .or. (iANr == 19) .or. (iANr == 20) .or. (iANr == 37) .or. &
      (iANr == 38) .or. (iANr == 55) .or. (iANr == 56) .or. (iANr == 87) .or. (iANr == 88)) Alpha(1) = Seven
  mR = nR-1
  call mma_allocate(NQ_Data(iNQ)%R_Quad,2,mR,Label='R_Quad')
  NQ_Data(iNQ)%R_Quad(:,:) = Zero
  call GenRadQuad_MK(NQ_Data(iNQ)%R_Quad,nR,nR_Eff(iNQ),rm(1),Alpha(1),iNQ)
  call Truncate_Grid(NQ_Data(iNQ)%r_Quad,mR,nR_Eff(iNQ),Radius_Max)
  mR = nR_Eff(iNQ)
  NQ_Data(iNQ)%R_max = NQ_Data(iNQ)%R_Quad(1,mR)

else if (Quadrature == 'BECKE') then

  iANr = NQ_Data(iNQ)%Atom_Nr
  RBS = Bragg_Slater(iANr)
  if (iANr == 1) then
    Alpha(1) = RBS
  else
    Alpha(1) = Half*RBS
  end if
  mR = nR-1
  call mma_allocate(NQ_Data(iNQ)%R_Quad,2,mR,Label='R_Quad')
  NQ_Data(iNQ)%R_Quad(:,:) = Zero
  call GenRadQuad_B(NQ_Data(iNQ)%R_Quad,nR,nR_Eff(iNQ),Alpha(1))
  call Truncate_Grid(NQ_Data(iNQ)%R_Quad,mR,nR_Eff(iNQ),Radius_Max)
  mR = nR_Eff(iNQ)
  NQ_Data(iNQ)%R_max = NQ_Data(iNQ)%R_Quad(1,mR)

else if (Quadrature == 'TA') then

  Alpha(1) = -One
  iANr = NQ_Data(iNQ)%Atom_Nr
  if (iANr == 1) then
    Alpha(1) = 0.8d00
  else if (iANr == 2) then
    Alpha(1) = 0.9d00
  else if (iANr == 3) then
    Alpha(1) = 1.8d00
  else if (iANr == 4) then
    Alpha(1) = 1.4d00
  else if (iANr == 5) then
    Alpha(1) = 1.3d00
  else if (iANr == 6) then
    Alpha(1) = 1.1d00
  else if (iANr == 7) then
    Alpha(1) = 0.9d00
  else if (iANr == 8) then
    Alpha(1) = 0.9d00
  else if (iANr == 9) then
    Alpha(1) = 0.9d00
  else if (iANr == 10) then
    Alpha(1) = 0.9d00
  else if (iANr == 11) then
    Alpha(1) = 1.4d00
  else if (iANr == 12) then
    Alpha(1) = 1.3d00
  else if (iANr == 13) then
    Alpha(1) = 1.3d00
  else if (iANr == 14) then
    Alpha(1) = 1.2d00
  else if (iANr == 15) then
    Alpha(1) = 1.1d00
  else if (iANr == 16) then
    Alpha(1) = 1.0d00
  else if (iANr == 17) then
    Alpha(1) = 1.0d00
  else if (iANr == 18) then
    Alpha(1) = 1.0d00
  else if (iANr == 19) then
    Alpha(1) = 1.5d00
  else if (iANr == 20) then
    Alpha(1) = 1.4d00
  else if (iANr == 21) then
    Alpha(1) = 1.3d00
  else if (iANr == 22) then
    Alpha(1) = 1.2d00
  else if (iANr == 23) then
    Alpha(1) = 1.2d00
  else if (iANr == 24) then
    Alpha(1) = 1.2d00
  else if (iANr == 25) then
    Alpha(1) = 1.2d00
  else if (iANr == 26) then
    Alpha(1) = 1.2d00
  else if (iANr == 27) then
    Alpha(1) = 1.2d00
  else if (iANr == 28) then
    Alpha(1) = 1.1d00
  else if (iANr == 29) then
    Alpha(1) = 1.1d00
  else if (iANr == 30) then
    Alpha(1) = 1.1d00
  else if (iANr == 31) then
    Alpha(1) = 1.1d00
  else if (iANr == 32) then
    Alpha(1) = 1.0d00
  else if (iANr == 33) then
    Alpha(1) = 0.9d00
  else if (iANr == 34) then
    Alpha(1) = 0.9d00
  else if (iANr == 35) then
    Alpha(1) = 0.9d00
  else if (iANr == 36) then
    Alpha(1) = 0.9d00
  else
    call WarningMessage(2,'TA grid not defined')
    write(6,*) ' TA grid not defined for atom number:',iANR
    call Abend()
  end if
  mR = nR-1
  call mma_allocate(NQ_Data(iNQ)%R_Quad,2,mR,Label='R_Quad')
  NQ_Data(iNQ)%R_Quad(:,:) = Zero
  call GenRadQuad_TA(NQ_Data(iNQ)%R_Quad,nR,nR_Eff(iNQ),Alpha(1))
  call Truncate_Grid(NQ_Data(iNQ)%R_Quad,mR,nR_Eff(iNQ),Radius_Max)
  mR = nR_Eff(iNQ)
  NQ_Data(iNQ)%R_max = NQ_Data(iNQ)%R_Quad(1,mR)

else if (Quadrature == 'LMG') then

  !                                                                    *
  !*********************************************************************
  !                                                                    *
  ! Generate radial quadrature. The first call will generate
  ! the size of the grid.

  nR = 1 ! Dummy size on the first call.
  Process = .false.
  call GenRadQuad_PAM(iNQ,nR_Eff(iNQ),rm,Alpha(1),Process,Dum,nR)

  nR = nR_Eff(iNQ)
  call mma_allocate(NQ_Data(iNQ)%R_Quad,2,nR,Label='R_Quad')
  NQ_Data(iNQ)%R_Quad(:,:) = Zero
  Process = .true.
  call GenRadQuad_PAM(iNQ,nR_Eff(iNQ),rm,Alpha(1),Process,NQ_Data(iNQ)%R_Quad,nR)
  NQ_Data(iNQ)%R_max = NQ_Data(iNQ)%R_Quad(1,nR)
  !                                                                    *
  !*********************************************************************
  !                                                                    *
# ifdef _DEBUGPRINT_
  write(6,*) 'GenRadQuad_PAM ----> GenVoronoi'
  write(6,*) 'nR_Eff=',nR_Eff(iNQ)
  write(6,*) 'rm : ',rm(1),rm(2)
  write(6,*) 'Alpha : ',Alpha(1),Alpha(2)
# endif
else
  call WarningMessage(2,'Invalid quadrature scheme:'//Quadrature)
  call Quit_OnUserError()
end if

#ifdef _DEBUGPRINT_
write(6,*)
write(6,*) ' ******** The radial grid ********'
write(6,*)
write(6,*) 'Initial number of radial grid points=',nR
write(6,*) 'iNQ=',iNQ
write(6,*) 'Effective number of radial grid points=',nR_Eff(iNQ)
do iR=1,nR_Eff(iNQ)
  write(6,*) NQ_Data(iNQ)%R_Quad(1,iR),NQ_Data(iNQ)%R_Quad(2,iR)
end do
write(6,*)
write(6,*) ' *********************************'
write(6,*)
#endif
!                                                                      *
!***********************************************************************
!                                                                      *

return
! Avoid unused argument warnings
if (.false.) call Unused_real_array(Coor)

end subroutine GenVoronoi
