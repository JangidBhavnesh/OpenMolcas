!***********************************************************************
! This file is part of OpenMolcas.                                     *
!                                                                      *
! OpenMolcas is free software; you can redistribute it and/or modify   *
! it under the terms of the GNU Lesser General Public License, v. 2.1. *
! OpenMolcas is distributed in the hope that it will be useful, but it *
! is provided "as is" and without any express or implied warranties.   *
! For more details see the full text of the license in the file        *
! LICENSE or in <http://www.gnu.org/licenses/>.                        *
!***********************************************************************

subroutine GiveMeInfo(nBB,nntyp,natyp,BasCoo,iCon,nPrim,nBA,nCBoA,nBona,ipExpo,ipCont,nSh,nfSh,nSize,iPrint,MxAtQ,MxPrCon,MxBasQ, &
                      MxAngqNr,ipAcc,nACCSize)

use Basis_Info
use Center_Info
use Her_RW
use Real_Spherical
implicit real*8(a-h,o-z)
!----------------------------------------------------------------------*
! Include files that got to do with the info-file generated by seward. *
!----------------------------------------------------------------------*
#include "numbers.fh"
#include "WrkSpc.fh"
#include "stdalloc.fh"
!----------------------------------------------------------------------*
! Ordinary variables.                                                  *
!----------------------------------------------------------------------*
dimension BasCoo(3,MxBasQ), nBona(MxAtQ)
dimension nSh(MxAtQ), nFSh(MxAtQ,MxAngqNr), iCon(MxAtQ,MxPrCon)
dimension natyp(MxAtQ), nPrim(MxBasQ), nBA(MxAtQ)
dimension nCBoA(MxAtQ,MxAngqNr)
real*8, allocatable :: TEMP1(:), TEMP2(:)
logical DoRys

!----------------------------------------------------------------------*
! Initialize in order to read properly from the info file.             *
!----------------------------------------------------------------------*
call Seward_Init()

!----------------------------------------------------------------------*
! GetInf reads everything in the runfile and puts it in variables      *
! in modules.                                                          *
!----------------------------------------------------------------------*
nDiff = 0
DoRys = .false.
call GetInf(DoRys,nDiff)

!----------------------------------------------------------------------*
! Set nntyp.                                                           *
!----------------------------------------------------------------------*
nntyp = nCnttp

!----------------------------------------------------------------------*
! Compute what we came here for. iBasAng will contain nBas elements    *
! with integers, such that 1=s-orbitals, 2=p-orbitals, 3=d-orbitals... *
!----------------------------------------------------------------------*
!ii = 0 !ii is number of basis sets.
!10 Continue
!ii = ii+1
!if (dbsc(ii)%nCntr /= 0) Go To 10
!ii = ii-1
!if (ii == 0) then
!  write(6,*)
!  write(6,*) 'ERROR in GiveMeInfo. No atoms?'
!end if
ii = nCnttp

kaunta = 0
kaunt = 0
kaunter = 0
krekna = 0
MaxAng = 0
do i=1,ii
  kauntSav = kaunt
  do ioio=1,dbsc(i)%nCntr
    krekna = krekna+1
    krekna2 = 0
    kaunt = kauntSav
    kaunterPrev = kaunter
    nBA(krekna) = dbsc(i)%nShells
    if (nBA(krekna) > MaxAng) MaxAng = nBA(krekna)
    do j=1,dbsc(i)%nShells
      kaunt = kaunt+1
      krekna2 = krekna2+1
      nCBoA(krekna,krekna2) = Shells(kaunt)%nBasis
      do jj=1,Shells(kaunt)%nBasis
        kaunter = kaunter+1
      end do
    end do
    kaunta = kaunta+1
    nBonA(kaunta) = kaunter-kaunterPrev  !Number of bases on each atom used below.
  end do
end do

!----------------------------------------------------------------------*
! And now coordinates of each basis.                                   *
!----------------------------------------------------------------------*
kaunter = 0
kaunt = 0
do i=1,ii
  do j=1,dbsc(i)%nCntr
    kaunt = kaunt+1
    do kk=1,nBonA(kaunt)
      kaunter = kaunter+1
      do k=1,3
        BasCoo(k,kaunter) = dbsc(i)%Coor(k,j)
      end do
    end do
  end do
end do

!----------------------------------------------------------------------*
! Now get info regarding the contraction. Icon is an array that for    *
! each basis type contain n1+n2+...+nx elements where n1 is the number *
! of contracted basis functions of s-type, n2 the same number for      *
! p-type etc. The value of the first n1 elements is the number of      *
! primitive basis functions of s-type, etc. So a contraction 7s3p.4s1p *
! generates the vector 7,7,7,7,3. We also compute natyp and also       *
! collect all exponents and contraction coefficients. These are stored *
! dynamically and then we return the pointers only.                    *
!----------------------------------------------------------------------*
kaunt = 0
do i=1,ii
  kaunter = 0
  do k=1,dbsc(i)%nShells
    kaunt = kaunt+1
    do ll=1,Shells(kaunt)%nBasis
      kaunter = kaunter+1
      Icon(i,kaunter) = Shells(kaunt)%nExp
    end do
  end do
end do

ndc = 0
iAngSav = 1
nSize = 0
kaunt = 0
do kk=1,ii !Just to get size of vector
  do kkk=1,dbsc(kk)%nShells
    kaunt = kaunt+1
    nSize = nSize+Shells(kaunt)%nBasis*Shells(kaunt)%nExp
  end do
end do
call GetMem('Exponents','Allo','Real',ipExpo,nSize*MxAtQ)
call GetMem('ContrCoef','Allo','Real',ipCont,nSize*MxAtQ)
call FZero(Work(ipExpo),nSize*MxAtQ)
call FZero(Work(ipCont),nSize*MxAtQ)

do iCnttp=1,nCnttp  !Here we set NaTyp.
  jSum = 0
  iTemp = 0
  nVarv = dbsc(iCnttp)%nShells
  nSh(iCnttp) = nVarv
  M = iCnttp-1
  do iCnt=1,dbsc(iCnttp)%nCntr
    ndc = ndc+1
    iTemp = iTemp+dc(ndc)%nStab
  end do
  NaTyp(iCnttp) = iTemp
  do iAng=0,nVarv-1  !And in this loop we get hold of the
    !contraction coefficients and the exponents.
    iCount = iAng+iAngSav
    iPrim = Shells(iCount)%nExp
    iBas = Shells(iCount)%nBasis
#   ifdef _DEBUGPRINT_
    call RecPrt('Exp',' ',Shells(iCount)%Exp,iPrim,1)
    call RecPrt('Cff',' ',Shells(iCount)%pCff,iPrim,iBas)
#   endif
    nfSh(iCnttp,iAng+1) = iBas
    do i=1,iBas
      call dCopy_(iPrim,Shells(iCount)%Exp,1,Work(ipExpo+jSum*MxAtQ+M),MxAtQ)
      call dCopy_(iPrim,Shells(iCount)%pCff(1,i),1,Work(ipCont+jSum*MxAtQ+M),MxAtQ)
      jSum = jSum+iPrim
    end do
  end do
  iAngSav = iAngSav+iAng
end do
if (iPrint >= 30) then
  write(6,*) 'Exp.'
  write(6,'(10G13.4)') (Work(ipExpo+k),k=0,nSize*MxAtQ-1)
  write(6,*) 'Contr.'
  write(6,'(10G13.4)') (Work(ipCont+k),k=0,nSize*MxAtQ-1)
end if

!----------------------------------------------------------------------*
! Contruct the nPrim vector.                                           *
!----------------------------------------------------------------------*
iBas = 0
do i=1,nntyp
  na = natyp(i)
  do j=1,na
    ind = 0
    nshj = nsh(i)
    do k=1,nshj
      nnaa = nfsh(i,k)
      do l=1,nnaa
        iBas = iBas+1
        ind = ind+1
        nPrim(iBas) = iCon(i,ind)
      end do
    end do
  end do
end do

! Then since overlap integrations are in cartesian coordinates while
! the AO-basis is spherical, we need transformation matrix for this.
! To our great joy, old reliable Seward computes this matrix of any
! order (within Molcas limits). Due to conflicting order conventions,
! some numbers gymnastics are required.

MaxAng = MaxAng-1
nSize = (2*MaxAng+1)*(MaxAng+1)*(MaxAng+2)/2
nACCSize = 0
do i=2,MaxAng
  nACCSize = nACCSize+(2*i+1)*(i+1)*(i+2)/2
end do
nSumma = 0
call mma_allocate(TEMP1,nSize,Label='TEMP1')
call mma_allocate(TEMP2,nSize,Label='TEMP2')
call GetMem('AccTransa','Allo','Real',ipAcc,nACCSize)

do i=2,MaxAng
  ind1 = (i+1)*(i+2)/2
  ind2 = 2*i+1
  iHowMuch = ind1*ind2
  call DCopy_(iHowMuch,RSph(ipSph(i)),iONE,TEMP1,iONE)
  ind3 = 1
  do jj=1,ind1
    call dcopy_(ind2,TEMP1(jj),ind1,TEMP2(ind3),iONE)
    ind3 = ind3+ind2
  end do
  !call recprt('FFF',' ',TEMP1,(i+1)*(i+2)/2,2*i+1)
  !call recprt('GGG',' ',TEMP2,ind2,ind1)
  call dcopy_(iHowMuch,TEMP2,iONE,Work(ipAcc+nSumma),iONE)
  nSumma = nSumma+iHowMuch
end do

call mma_deallocate(TEMP1)
call mma_deallocate(TEMP2)
!----------------------------------------------------------------------*
! Make deallocations. They are necessary because of the getinf.        *
!----------------------------------------------------------------------*
call ClsSew()

return
! Avoid unused argument warnings
if (.false.) call Unused_integer(nBB)

end subroutine GiveMeInfo
